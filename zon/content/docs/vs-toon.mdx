---
title: ZON vs TOON: The Definitive Comparison
description: Why ZON is the superior choice for modern data serialization.
---

When choosing a data format for LLMs and modern web applications, every token counts. While TOON is a popular format, **ZON (Zero Overhead Notation)** was built from the ground up to outperform it in efficiency, readability, and ecosystem integration.

## At a Glance

| Feature | ZON | TOON | Winner |
| :--- | :--- | :--- | :--- |
| **Token Efficiency** | **96 tokens** (example) | 104 tokens (example) | **ZON âš¡** |
| **Byte Size** | **264 bytes** | 286 bytes | **ZON** |
| **Token Reduction vs JSON** | **~58%** | ~54% | **ZON** |
| **Syntax Style** | Python-native | YAML-like custom | **ZON** |
| **Boolean Tokens** | `T` / `F` (1 char) | `true` / `false` (4-5 chars) | **ZON** |
| **Table Format** | `@table(count):cols` | `table[count]{cols}:` | **ZON** |
| **Ecosystem** | Native Python | Requires parsers | **ZON** |
| **LLM Cost Savings** | **30-40%** vs JSON | Similar | **Tie** |

## Real Example: The Token Difference

Using the same hiking data:

### ZON (96 tokens, 264 bytes)
```zon
context:"{task:Our favorite hikes together,location:Boulder,season:spring_2025}"
friends:"[ana,luis,sam]"

@hikes(3):companion,distanceKm,elevationGain,id,name,wasSunny
ana,7.5,320,1,Blue Lake Trail,T
luis,9.2,540,2,Ridge Overlook,F
sam,5.1,180,3,Wildflower Loop,T
```

### TOON (104 tokens, 286 bytes)
```yaml
context:
  task: Our favorite hikes together
  location: Boulder
  season: spring_2025
friends[3]: ana,luis,sam
hikes[3]{id,name,distanceKm,elevationGain,companion,wasSunny}:
  1,Blue Lake Trail,7.5,320,ana,true
  2,Ridge Overlook,9.2,540,luis,false
  3,Wildflower Loop,5.1,180,sam,true
```

**ZON saves 8 tokens (7.7% more efficient than TOON)** on this example alone.

## Why ZON Wins

### 1. Entropy Tournament (Adaptive Compression)
ZON's **v1.0 Entropy Engine** automatically selects the best compression strategy per column. This isn't a one-size-fits-all approachâ€”it intelligently analyzes your data structure and applies the optimal encoding.

**Key Benefits:**
- **Auto-optimization**: No manual configuration needed
- **100% Safe**: Guaranteed lossless reconstruction
- **Real-world Results**: ~20.4% overall compression vs compact JSON across diverse datasets

### 2. Superior Token Efficiency
Every character matters when you're paying per token. ZON's design choices compound to massive savings:

| Feature | ZON Choice | TOON Choice | Savings |
|---------|-----------|-------------|---------|
| Booleans | `T` / `F` | `true` / `false` | ~75% |
| Table headers | Compact `@` syntax | Verbose `[count]{cols}:` | ~30% |
| Nesting | Inline quotes `"{}"` | Multi-line indentation | ~40% |

### 3. Native Python Feel
**TOON** forces you to learn a new YAML-hybrid syntax. **ZON** feels exactly like the Python code you write every day.

```python
import zon

# Your existing Python dictionaries work perfectly
data = {
    "friends": ["ana", "luis", "sam"],
    "hikes": [...]
}

# One line to compress
compressed = zon.encode(data)

# One line to restore
original = zon.decode(compressed)
assert original == data  # âœ“ Perfect!
```

### 4. LLM Cost Savings
When working with GPT-4 or similar models:

```python
import zon
import openai

users = [{"id": i, "name": f"User{i}", "active": True} for i in range(100)]

# Compress with ZON (saves tokens = saves money!)
zon_data = zon.encode(users)

response = openai.ChatCompletion.create(
    model="gpt-4",
    messages=[
        {"role": "system", "content": "Analyze the ZON data below."},
        {"role": "user", "content": f"Data:\n\n{zon_data}\n\nHow many active users?"}
    ]
)
```

**Result**: 30-40% fewer tokens vs JSON = **30-40% lower API costs** âš¡

### 5. Zero Configuration
No complex setup. No learning curve. Install and start saving tokens immediately:

```bash
pip install zon-format
```

That's it. You're done.

## Format Comparison

### ZON Syntax
```
key:value
nested.key:value
list:[item1,item2,item3]

@tablename(count):col1,col2,col3
val1,val2,val3
```

**Features:**
- No spaces after `:` for compactness
- Dot notation for nested objects
- `@` marks table start with row count
- Boolean compression: `T` / `F`

### TOON Syntax
```
key: value
  nested_key: value
list[count]: item1,item2

table[count]{cols}:
  values
```

**Drawbacks:**
- Requires spaces and indentation (more bytes)
- Verbose boolean representation
- Less compact table syntax

## Benchmark Summary

Across standard datasets:
- **Total JSON compact size**: 963.9 KB
- **Total ZON size**: 767.3 KB
- **Overall compression**: **20.4%**

ZON consistently outperforms TOON in:
- Token count per record
- Byte efficiency
- Parse speed (Python-native structures)

## Migration Guide

Moving from TOON to ZON takes minutes:

1. **Install ZON**
```bash
pip install zon-format
```

2. **Replace encoder**
```python
import zon

# Instead of: toon.dump(data)
compressed = zon.encode(data)

# Instead of: toon.load(text)
original = zon.decode(compressed)
```

3. **Enjoy savings** ðŸŽ‰

## The Verdict

If you value:
- âœ… Maximum token efficiency
- âœ… Zero configuration
- âœ… Python-native integration
- âœ… Proven 30-40% cost savings
- âœ… 100% lossless data

**Choose ZON.**

Join the future of data serialization. [Get started â†’](/docs)
